[[Node]]

O Express √© um framework com um objetivo central: receber requisi√ß√µes e enviar respostas. Voc√™ j√° viu como ele usa fun√ß√µes que recebem requisi√ß√£o (`req`) e resposta (`res`) como par√¢metros. Agora, voc√™ ver√° como essas fun√ß√µes podem ser¬†**decompostas**¬†em fun√ß√µes menores, que podem ser aproveitadas em diversas rotas.

Cada fun√ß√£o ter√° uma responsabilidade √∫nica, se essa fun√ß√£o capturar algum problema, uma resposta de erro ser√° retornada para a pessoa usu√°ria.

Exemplos:

-   Formato de e-mail n√£o apropriado;
-   CPF com formato inv√°lido;
-   Pessoa usu√°ria n√£o tem permiss√£o de acesso.

Agora, se estiver tudo certo, ser√° indicado no final dessa fun√ß√£o, seguir para a pr√≥xima fun√ß√£o da rota (fazendo uma valida√ß√£o diferente). Com isso, ser√£o feitas quantas fun√ß√µes forem necess√°rias, at√© que uma delas devolva uma resposta a pessoa usu√°ria. Esse √© um estilo de¬†**composi√ß√£o de fun√ß√µes**¬†chamado¬†**middlewares**.

A primeira coisa que voc√™ precisa saber sobre middlewares √©:¬†**no Express toda fun√ß√£o passada para uma rota √© um middleware**.

_Calma a√≠, como assim?_¬†ü§î

Para o Express, um¬†[middleware](https://expressjs.com/pt-br/guide/using-middleware.html)¬†√© uma fun√ß√£o que realiza o tratamento de uma requisi√ß√£o HTTP e que pode responder essa request ou chamar o pr√≥ximo middleware.

> ü§´¬†**Bom, para te contar um segredo:**¬†estamos usando middlewares desde o come√ßo deste conte√∫do, mas com outro nome! At√© agora, nos referimos aos middlewares como¬†`callbacks`¬†ao falar sobre roteamento e defini√ß√£o de endpoints. Acontece que todos os callbacks que mostramos nessas rotas s√£o middlewares.

**Na pr√°tica, middlewares recebem tr√™s par√¢metros:**¬†`req`,¬†`res`¬†e¬†`next`, exatamente como as fun√ß√µes callback que usamos at√© agora para registrar rotas.

**Middlewares n√£o precisam retornar nada.**¬†O fato √© que o Express ignora o retorno dos middlewares, visto que o importante √© se aquele middleware chamou ou n√£o um m√©todo que responda a request, e se ele chamou ou n√£o a fun√ß√£o¬†`next`.

Bora estudar como refatorar um middleware? üöÄ

## Refatorando um middleware

Agora que voc√™ estudou o que s√£o middlewares, o pr√≥ximo passo ser√° refatorar a API de times de futebol e aplicar na pr√°tica o aprendizado de middlewares.

Para isso, preste aten√ß√£o especialmente nos m√©todos¬†`POST`¬†e¬†`PUT`:

Vamos para o c√≥digo?

No c√≥digo abaixo ter√° o CRUD completo, observe este c√≥digo novamente, com o destaque para as rotas¬†`PUT`¬†e¬†`POST`:

```js
// src/server

const app = require('./app');

app.listen(3001, () => console.log('server running on port 3001'));
```

```js
// src/app.js

const express = require('express');

const app = express();

let nextId = 3;
const teams = [
  { id: 1, nome: 'S√£o Paulo Futebol Clube', sigla: 'SPF' },
  { id: 2, nome: 'Sociedade Esportiva Palmeiras', sigla: 'PAL' },
];

app.use(express.json());

app.get('/teams', (req, res) => res.json(teams));

app.get('/teams/:id', (req, res) => {
  const id = Number(req.params.id);
  const team = teams.find(t => t.id === id);
  if (team) {
    res.json(team);
  } else {
    res.sendStatus(404);
  }
});

app.post('/teams', (req, res) => {
  const requiredProperties = ['nome', 'sigla'];
  if (requiredProperties.every((property) => property in req.body)) {
    const team = { id: nextId, ...req.body };
    teams.push(team);
    nextId += 1;
    res.status(201).json(team);
  } else {
    res.sendStatus(400);
  }
});

app.put('/teams/:id', (req, res) => {
  const id = Number(req.params.id);
  const requiredProperties = ['nome', 'sigla'];
  const team = teams.find(t => t.id === id);
  if (team && requiredProperties.every((property) => property in req.body)) {
    const index = teams.indexOf(team);
    const updated = { id, ...req.body };
    teams.splice(index, 1, updated);
    res.status(201).json(updated);
  } else {
    res.sendStatus(400);
  }
});

app.delete('/teams/:id', (req, res) => {
  const id = Number(req.params.id);
  const team = teams.find(t => t.id === id);
  if (team) {
    const index = teams.indexOf(team);
    teams.splice(index, 1);
  }
  res.sendStatus(204);
});

module.exports = app;
```

> Lembre-se que para testar, o express deve ter sido instalado na aplica√ß√£o. Para isso, voc√™ pode usar o comando¬†`npm install express@4.17.1 --save-exact`.

> Para instalar e configurar as depend√™ncias de desenvolvimento, consulte o conte√∫do do segundo dia desta se√ß√£o, na li√ß√£o ‚ÄúExpress‚Äù. üòâ

Voc√™ reparou que precisou validar os dados enviados duas vezes: uma para a rota¬†`PUT`¬†e outra para rota¬†`POST`, de modo a garantir que as informa√ß√µes esperadas (nome e sigla) fossem enviadas?

Provavelmente, lhe deu vontade de isolar esse c√≥digo em uma fun√ß√£o separada, n√£o √© mesmo? Assim n√£o precisaria editar dois trechos diferentes de c√≥digo, caso um dia quisesse ampliar a valida√ß√£o, de modo a conferir se a sigla tem exatos tr√™s caracteres, por exemplo.

> Manter c√≥digo duplicado √© uma receita certeira para bugs.¬†_Don‚Äôt Repeat Yourself_!

O Express permite que o tratamento de uma rota seja decomposto em v√°rias fun√ß√µes¬†**middlewares**. Um middleware deve fazer apenas o seu pr√≥prio trabalho (por exemplo, conferir um cabe√ßalho), e ent√£o escolher entre responder (`res`) a requisi√ß√£o ou chamar o pr√≥ximo middleware (`next`). Assim, uma rota pode ser tratada por uma sequ√™ncia de middlewares, cada um fazendo uma parte do tratamento da requisi√ß√£o.

Vamos ver como ficaria um middleware de valida√ß√£o das propriedades necess√°rias para a aplica√ß√£o? üòé

```js
// src/app.js

// ...
const validateTeam = (req, res, next) => {
  const requiredProperties = ['nome', 'sigla'];
  if (requiredProperties.every((property) => property in req.body)) {
    next(); // Chama o pr√≥ximo middleware
  } else {
    res.sendStatus(400); // Ou j√° responde avisando que deu errado
  }
};

// Arranja os middlewares para chamar validateTeam primeiro
app.post('/teams', validateTeam, (req, res) => {
  const team = { id: nextId, ...req.body };
  teams.push(team);
  nextId += 1;
  res.status(201).json(team);
});

app.put('/teams/:id', validateTeam, (req, res) => {
  const id = Number(req.params.id);
  const team = teams.find(t => t.id === id);
  if (team) {
    const index = teams.indexOf(team);
    const updated = { id, ...req.body };
    teams.splice(index, 1, updated);
    res.status(201).json(updated);
  } else {
    res.sendStatus(400);
  }
});

// module.exports = app;
```

Repare como o m√©todo POST foi definido de uma maneira mais direta e reaproveit√°vel, deixando os detalhes de valida√ß√£o para o middleware¬†`validateTeam`. Se a requisi√ß√£o chegou no segundo middleware, ele pode criar o time sem se preocupar com mais nada.

Os middlewares seguintes podem receber o¬†`next`¬†como um terceiro par√¢metro, mas¬†**geralmente o √∫ltimo middleware de uma rota precisa responder a requisi√ß√£o**. Portanto, se ele n√£o for chamar outro middleware, n√£o h√° necessidade de usar o objeto¬†`next`¬†e voc√™ pode escrever a fun√ß√£o recebendo apenas dois par√¢metros: os objetos¬†`req`¬†e¬†`res`.

## E o que o middleware validateTeam faz?

1Ô∏è‚É£ Faz uma valida√ß√£o b√°sica que apenas confere se todas as propriedades esperadas est√£o presentes no¬†`req.body`.

2Ô∏è‚É£ Se a valida√ß√£o aprovar, esse middleware endere√ßa a requisi√ß√£o para o pr√≥ximo middleware, que efetivamente cria o time.

3Ô∏è‚É£ Se a valida√ß√£o falhar, esse middleware retorna uma resposta com¬†`status 400`¬†e¬†**nunca chama o pr√≥ximo middleware**.¬†`400`¬†√© o c√≥digo HTTP para¬†`Bad Request`, indicando que existe algo errado na requisi√ß√£o. Para mais informa√ß√µes sobre c√≥digos HTTP, confira a¬†[documenta√ß√£o](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status)¬†no site da MDN (Mozilla Developer Network).

Observe o fluxo da requisi√ß√£o no diagrama abaixo:

![Passo a passo da requisi√ß√£o passando pelos middlewares](https://content-assets.betrybe.com/prod/Passo%20a%20passo%20da%20requisi%C3%A7%C3%A3o%20passando%20pelos%20middlewares.png)
> Passo a passo da requisi√ß√£o passando pelos middlewares

Veja um exemplo de requisi√ß√£o que passa na valida√ß√£o:

![Requisi√ß√£o correta do tipo POST feita √† rota teams](https://content-assets.betrybe.com/prod/Requisi%C3%A7%C3%A3o%20correta%20do%20tipo%20POST%20feita%20%C3%A0%20rota%20teams.gif)

Requisi√ß√£o correta do tipo POST feita √† rota /teams

Agora, veja um exemplo que n√£o passa:

![Requisi√ß√£o incorreta do tipo POST feita √† rota teams](https://content-assets.betrybe.com/prod/Requisi%C3%A7%C3%A3o%20incorreta%20do%20tipo%20POST%20feita%20%C3%A0%20rota%20teams.gif)

Requisi√ß√£o incorreta do tipo POST feita √† rota /teams

> üí° Experimente fazer a mesma requisi√ß√£o comentando a instru√ß√£o¬†`next()`¬†e voc√™ vai notar que a requisi√ß√£o¬†**nunca**¬†vai chegar na segunda rota e, por isso, voc√™ nunca ter√° uma resposta!

![Requisi√ß√£o correta do tipo POST feita √† rota recipes que n√£o responde](https://content-assets.betrybe.com/prod/Requisi%C3%A7%C3%A3o%20correta%20do%20tipo%20POST%20feita%20%C3%A0%20rota%20recipes%20que%20n%C3%A3o%20responde.gif)
>Requisi√ß√£o correta do tipo POST feita √† rota /recipes que n√£o responde


## Para Fixar



## Exerc√≠cio 1 


-   Crie um middleware¬†`existingId`¬†para garantir que o¬†`id`¬†passado como par√¢metro na rota¬†`GET /teams/:id`¬†existe no objeto¬†`teams`. Refatore essa rota para usar o middleware.

O objeto¬†`teams`¬†√© um array. O¬†`id`¬†recebido via par√¢metro¬†**√© sempre uma string**. Ent√£o precisamos converter primeiro antes de procurar pelo¬†`id`. Para confirmar se um valor existe podemos usar o m√©todo¬†`array.some`:

> src/app.js

```js
//...
const existingId = (req, res, next) => {
  const id = Number(req.params.id);

  if (teams.some((t) => t.id === id)) {
    // se existe, a requisi√ß√£o segue para o pr√≥ximo middleware
    return next();
  }

  // se n√£o existe, ent√£o vamos retornar o status HTTP 404
  res.sendStatus(404);
};
//...

// usa o middleware
app.get("/teams/:id", existingId, (req, res) => {
  const id = Number(req.params.id);
  const team = teams.find(t => t.id === id);
  res.json(team);
});
```

**Preciso usar¬†`return`¬†sempre que usar¬†`next()`?**¬†O importante aqui √© evitar que duas respostas sejam enviadas. Sem o¬†`return`¬†ali, chamar√≠amos o¬†`next()`¬†e depois do bloco¬†`if`¬†acabar√≠amos chamando¬†`res.sendStatus(404)`¬†tamb√©m! Uma alternativa seria usar¬†`else`, assim o c√≥digo depois do¬†`if`¬†fica inacess√≠vel se a condi√ß√£o for verdadeira:

```js
//...
const existingId = (req, res, next) => {
  const id = Number(req.params.id);

  if (teams.some((t) => t.id === id)) {
    // se existe, a requisi√ß√£o segue para o pr√≥ximo middleware
    next();
  } else {
    // se n√£o existe, ent√£o vamos retornar o status HTTP 404
    res.sendStatus(404);
  }
};
//...
```

---

## Exerc√≠cio 2

-   Reaproveite esse middleware e refatore as rotas¬†`PUT /teams/:id`¬†e¬†`DELETE /teams/:id`¬†para usarem ele tamb√©m.

Uma vez que o middleware foi criado, basta inseri-lo nas rotas e remover a l√≥gica duplicada:

> src/app.js

```js
//...
const existingId = (req, res, next) => {
  const id = Number(req.params.id);

  if (teams.some((t) => t.id === id)) {
    // se existe, a requisi√ß√£o segue para o pr√≥ximo middleware
    next();
  } else {
    // se n√£o existe, ent√£o vamos retornar o status HTTP 404
    res.sendStatus(404);
  }
};
//...
// a ordem √© significativa, embora neste caso fa√ßa pouca diferen√ßa
app.put('/teams/:id', existingId, validateTeam, (req, res) => {
  const id = Number(req.params.id);
  const team = teams.find(t => t.id === id);
  // n√£o precisamos mais conferir, com certeza o team existe
  const index = teams.indexOf(team);
  const updated = { id, ...req.body };
  teams.splice(index, 1, updated);
  res.status(201).json(updated);
});

app.delete('/teams/:id', existingId, (req, res) => {
  const id = Number(req.params.id);
  const team = teams.find(t => t.id === id);
  const index = teams.indexOf(team);
  teams.splice(index, 1);
  res.sendStatus(204);
});
//...
```

## Exerc√≠cio 3


√â fundamental lembrar do¬†`module.exports`¬†no arquivo novo. Podemos copiar a fun√ß√£o exatamente do mesmo jeito, s√≥ precisamos lembrar de export√°-la:


```js
// src/middlewares/validateTeam.js

const validateTeam = (req, res, next) => {
  const requiredProperties = ['nome', 'sigla'];
  if (requiredProperties.every((property) => property in req.body)) {
    next(); // Chama o pr√≥ximo middleware
  } else {
    res.sendStatus(400); // Ou j√° responde avisando que deu errado
  }
};

module.exports = validateTeam;
```

## Exerc√≠cio 4


Vamos seguir o mesmo racioc√≠nio que fizemos para isolar o middleware¬†`validateTeam`¬†aqui.

```js
// src/middlewares/existingId.js
const existingId = (req, res, next) => {
  const id = Number(req.params.id);
  if (teams.some((t) => t.id === id)) {
    // se existe, a requisi√ß√£o segue para o pr√≥ximo middleware
    next();
  } else {
    // se n√£o existe, ent√£o vamos retornar o status HTTP 404
    res.sendStatus(404);
  }
};
```

J√° no¬†`src/app.js`, ambas fun√ß√µes s√£o substitu√≠das, cada uma, por um¬†`require`. Repare no¬†_caminho relativo_, isto √©, o¬†`app.js`¬†est√° no diret√≥rio¬†`src`, e um middleware no¬†`src/middlewares/validateTeam.js`¬†e o outro no¬†`src/middlewares/existingId.js`. Relativamente, seria apenas¬†`./middleware/validateTeam.js`¬†e¬†`./middlewares/existingId.js`¬†respectivamente.

```js
// src/app.js

//...
// n√£o precisa do sufixo .js, o node sabe deduzir
const validateTeam = require('./middleware/validateTeam');
const existingId = require('./middleware/existingId');
//...
// o resto do arquivo fica id√™ntico
```

Nada muda nas rotas, porque o middleware continua acess√≠vel pela mesma vari√°vel.



#### Recursos adicionais

-   [Usando Middlewares](https://expressjs.com/pt-br/guide/using-middleware.html)
-   [Escrevendo Middlewares](https://expressjs.com/pt-br/guide/writing-middleware.html)
-   [Express - Middlewares](https://reflectoring.io/express-middleware/)
-   [Middleware no Express - JS](https://www.geeksforgeeks.org/middleware-in-express-js/)


###### Fonte: [Curse](https://app.betrybe.com/learn/course/5e938f69-6e32-43b3-9685-c936530fd326/module/94d0e996-1827-4fbc-bc24-c99fb592925b/section/2ed87e4f-9049-4314-8091-8f71b1925cf6/day/27d3ea73-4725-48c0-b38c-8acc4dc4d40a/lesson/e3f0b1ef-d574-45ef-abb3-22a6ea384448)
