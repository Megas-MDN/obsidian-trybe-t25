[[Node]]
[[Teste Assincrono]]

- [Testar j√° faz parte da sua rotina](#Testar%0dj√°%0dfaz%0dparte%0dda%0dsua%0drotina)
- [Tipos de teste](#Tipos%0dde%0dteste)
	- [Testes unit√°rios](#üëâ%0d**Testes%0dunit√°rios**)
	- [Testes de integra√ß√£o](#üëâ%0d**Testes%0dde%0dintegra√ß√£o**)
	- [Testes de Ponta-a-ponta](#üëâ%0d**Testes%0dde%0dPonta-a-ponta**)
- [Testes automatizados](#Testes%0dautomatizados)
	- [Ferramentas](#Ferramentas)
		- [Estruturando testes com o Mocha](#Estruturando%0dtestes%0dcom%0do%0dMocha)
		- [Aferindo testes com o Chai](#Aferindo%0dtestes%0dcom%0do%0dChai)
- [Testes de Integra√ß√£o](#Testes%0dde%0dIntegra√ß√£o)
- [Contratos de APIs](#Contratos%0dde%0dAPIs)
- [Definindo os cen√°rios de teste](#Definindo%0dos%0dcen√°rios%0dde%0dteste)



## Testar j√° faz parte da sua rotina

Antes de falarmos de testes automatizados e das ferramentas que podemos utilizar para testar nossos c√≥digos em Node.js, vamos pensar sobre algumas das experi√™ncias que j√° tivemos at√© aqui.

Muitas vezes, realizamos o mesmo teste alterando os dados de entrada¬†_(input)_¬†para garantir que a sa√≠da¬†_(output)_¬†era condizente com aquilo que foi codificado. Com certeza, muitas vezes o resultado n√£o era o esperado n√©? √Äs vezes faltava um¬†`if`, precisava de mais um par√¢metro ou at√© mesmo um retorno n√£o tratado como deveria. Esse processo pode ser chamado de¬†**‚Äútestes manuais‚Äù**, mas existem diversos tipos de testes, cada um com suas caracter√≠sticas e objetivos.

> Nos testes manuais, reexecutamos o c√≥digo algumas vezes, buscando validar se o comportamento do programa est√° ocorrendo conforme esperado. Al√©m disso, tamb√©m alteramos os par√¢metros de entrada para tentarmos garantir que tal funcionamento se mantenha mesmo com essas varia√ß√µes.

**‚è∞ Hora da pr√°tica**: imagine que queremos criar uma fun√ß√£o a qual receba a m√©dia das notas de uma pessoa e responda se ela foi aprovada ou n√£o, seguindo a seguinte regra:

![Cenarios](https://content-assets.betrybe.com/prod/Cenarios.png)

Cen√°rios!

O primeiro passo √© pensar na estrutura da nossa fun√ß√£o. Para isso, podemos fazer as seguintes perguntas:

-   Quantos e quais par√¢metros ela vai esperar?
    
-   Qual √© o tipo de resposta que ela vai retornar?
    

Nesse caso, nossa fun√ß√£o dever√° receber¬†**um par√¢metro ‚Äúm√©dia‚Äù**¬†e responder com¬†**‚Äúreprova√ß√£o‚Äù ou ‚Äúaprova√ß√£o‚Äù**.

Tendo em mente esses questionamentos, podemos partir para a implementa√ß√£o e chegar no seguinte c√≥digo:

> examples/calculaSituacao.js

```js
function calculaSituacao(media) {
  if (media > 7) {
    return 'aprova√ß√£o';
  }

  return 'reprova√ß√£o';
}

module.exports = calculaSituacao;
```

Tendo o c√≥digo da fun√ß√£o implementado, precisamos garantir que seu comportamento √© o esperado e que ele n√£o mudar√° sem aviso - Para isto, devemos testar seus casos de uso e verificar se ela exibe, para cada caso, o comportamento esperado. Algumas das coisas que precisamos garantir s√£o:

-   Se passado um valor¬†**menor que 7**, por exemplo¬†**4**, a resposta deve ser¬†**‚Äúreprova√ß√£o‚Äù**;
    
-   Se passado um valor¬†**maior que 7**, por exemplo¬†**9**, a resposta ser¬†**‚Äúaprova√ß√£o‚Äù**;
    
-   N√£o podemos esquecer do ‚ÄúOU‚Äù, sendo assim, se passado¬†**7**, a resposta deve ser¬†**‚Äúaprova√ß√£o‚Äù**;
    

Para validar esses cen√°rios que pensamos, podemos escrever algumas chamadas na nossa fun√ß√£o:

```js
const calculaSituacao = require('./examples/calculaSituacao');

console.log(calculaSituacao(4));
// console: reprova√ß√£o
```

üëâ Se pensarmos nessa forma manual de testar aplica√ß√µes, precisamos de tr√™s cen√°rios de testes distintos:

1Ô∏è‚É£ quando a m√©dia for¬†**menor que sete**;

2Ô∏è‚É£ quando a m√©dia for¬†**maior que sete**;

3Ô∏è‚É£ quando a m√©dia for¬†**igual a sete**.

De olho na dica üëÄ: podemos programar um script simples com esses testes e adicionar algumas mensagens para nos ajudar a verificar se a resposta dada √© aquela que esperamos:



```js
const calculaSituacao = require('./examples/calculaSituacao');

console.log('Quando a m√©dia for menor que 7, retorna "reprova√ß√£o":');

const respostaCenario1 = calculaSituacao(4);
if (respostaCenario1 === 'reprova√ß√£o') {
  console.log(`Ok üöÄ`);
} else {
  console.error('Resposta n√£o esperada üö®');
}
// console:
// Quando a m√©dia for menor que 7, retorna "reprova√ß√£o":
// Ok üöÄ

console.log('Quando a m√©dia for maior que 7, retorna "aprova√ß√£o":');

const respostaCenario2 = calculaSituacao(9);
if (respostaCenario2 === 'aprova√ß√£o') {
  console.log(`Ok üöÄ`);
} else {
  console.error('Resposta n√£o esperada üö®');
}
// console:
// Quando a m√©dia for maior que 7, retorna "aprova√ß√£o":
// Ok üöÄ

console.log('Quando a m√©dia for igual a 7, retorna "aprova√ß√£o":');

const respostaCenario3 = calculaSituacao(7);
if (respostaCenario3 === 'aprova√ß√£o') {
  console.log(`Ok üöÄ`);
} else {
  console.error('Resposta n√£o esperada üö®');
}
// console:
// Quando a m√©dia for igual a 7, retorna "aprova√ß√£o":
// Resposta n√£o esperada üö®
```

**Espere, temos um bug aqui!**¬†üêû

Voc√™ observou que um dos casos de teste falhou - fizemos isso propositalmente para simular uma situa√ß√£o normal do dia a dia de uma pessoa programadora. Nesse caso, pode ser um detalhe em uma fun√ß√£o simples, mas em sistemas mais complexos, onde temos diversos pontos diferentes interligados e v√°rias pessoas trabalhando no mesmo c√≥digo, um cen√°rio de falha √© ainda maior. Que tal tentar encontrar o erro antes de mostrarmos ele pra voc√™? ;)

> O que poder√≠amos fazer em uma situa√ß√£o dessas √© implementar a corre√ß√£o e chamar as fun√ß√µes novamente, garantindo que dessa vez todos os cen√°rios est√£o cobertos, inclusive aqueles que j√° estavam funcionando antes da corre√ß√£o.

Vamos aproveitar para implementar esta corre√ß√£o no c√≥digo.

> examples/calculaSituacao.js

```js
// function calculaSituacao(media) {
  if (media >= 7) {
//     return 'aprova√ß√£o';
//   }

//   return 'reprova√ß√£o';
// }

// module.exports = calculaSituacao;
```

E por fim vamos executar novamente os testes e observar que todos s√£o aprovados.

Para nos ajudar na atividade de teste, existem etapas bem definidas que tem como objetivo garantir que diferentes aspectos do nosso c√≥digo est√£o sendo cobertos (testados). Como exemplo, os tipos de teste apresentam diferentes perspectivas sobre o nosso c√≥digo que devem ser observadas durante o teste.

Bora dar uma olhada nesses tipos de teste? ü§ì


# Tipos de teste

Uma quest√£o importante para se ter em mente ao criar cen√°rios de teste √© o¬†**escopo**¬†e a¬†**intera√ß√£o**¬†dos testes. Para isso, existem algumas divis√µes arbitr√°rias que nos ajudam a pensar em uma ordem de desenvolvimento de testes, as mais comuns s√£o:


### üëâ¬†**Testes unit√°rios**:

Consideram um escopo limitado a um pequeno fragmento do seu c√≥digo com intera√ß√£o m√≠nima entre recursos externos.

‚ö†Ô∏è Aviso: Para exemplificar esse tipo de teste, vamos imaginar o teste unit√°rio de um carro. üöó

> O motor precisa ser testado para saber se ele tem pot√™ncia e torque; j√° os pneus s√£o testados para saber se t√™m boa ader√™ncia no asfalto. Al√©m disso, testamos o assento do motorista para saber se √© confort√°vel e ergon√¥mico e tamb√©m o volante para saber se √© f√°cil manusear e ester√ßar.

![Teste de unidades do carro](https://content-assets.betrybe.com/prod/Teste%20de%20unidades%20do%20carro.png)

Teste de unidades do carro.

### üëâ¬†**Testes de integra√ß√£o**:

Presumem a jun√ß√£o de m√∫ltiplos escopos (que tecnicamente devem possuir, cada um, seus pr√≥prios testes) com intera√ß√µes entre eles.

> Voltando ao exemplo do carro, agora nos testes de integra√ß√£o, ao acelerar testamos se o motor permanece em uma velocidade constante e se, ao ester√ßar o volante, os pneus dianteiros s√£o orientados corretamente para a dire√ß√£o desejada. Al√©m disso, testamos se, ao se acomodar no assento da pessoa motorista, √© f√°cil manusear o volante e o c√¢mbio.

![Teste de integra√ß√£o do carro](https://content-assets.betrybe.com/prod/Teste%20de%20integra%C3%A7%C3%A3o%20do%20carro.png)

Teste de integra√ß√£o do carro.

### üëâ¬†**Testes de Ponta-a-ponta**: 

Tamb√©m chamados de Fim-a-fim¬†_(End-to-End; E2E)_, pressup√µem um fluxo de intera√ß√£o completo com a aplica√ß√£o, de uma ponta a outra.

Aqui, poder√≠amos pensar em uma API que utiliza nossa calculadora - assim como diversas outras fun√ß√µes mais complexas - na hora de realizar uma opera√ß√£o de venda de produtos.

De olho na dica üëÄ: Esse teste √© o mais completo, pois necessita que todos os demais testes tenham sido desenvolvidos.

> Ainda no exemplo do carro, no teste Ponta-a-Ponta (PaP) podemos fazer um test-drive de impacto para avaliar todos os aspectos, realizando, por exemplo, uma corrida com v√°rios carros em um circuito.

![Teste End-to-End do carro](https://content-assets.betrybe.com/prod/Teste%20End-to-End%20do%20carro.png)

Teste End-to-End do carro.

‚ö†Ô∏è Aviso: √â importante ressaltar que nenhum tipo de teste √© mais importante que o outro, √© a combina√ß√£o entre eles que vai garantir a qualidade do seu c√≥digo.

Agora que voc√™ j√° conhece os tipos de teste, podemos seguir pensando em formas mais eficientes para execut√°-los.

> Executar os testes ‚Äúmanualmente‚Äù toda vez que uma nova funcionalidade √© desenvolvida, √© uma tarefa √°rdua, repetitiva e propensa √† erros.

**‚è∞ Hora da reflex√£o**: Como pessoas desenvolvedoras, somos capazes de construir solu√ß√µes para tornar processos mais eficientes e r√°pidos, sendo menos repetitivos e sujeitos a erros humanos. Com isso, por que n√£o automatizamos esse processo tamb√©m, colhendo essas e outras vantagens?


# Testes automatizados

Automatizar testes √© uma necessidade t√£o presente no dia a dia dos times de desenvolvimento, que √© assunto constante de discuss√µes e evolu√ß√µes.

Hoje, j√° √© um assunto amplamente difundido sendo poss√≠vel encontrar diversos tipos, t√©cnicas, implementa√ß√µes e ferramentas diferentes. Essa base s√≥lida sobre o assunto nos ajuda bastante durante o processo de aprendizagem, j√° que temos diversas ferramentas consolidadas prontas para serem utilizadas.

Vamos conhecer algumas delas?

## Ferramentas

Existem v√°rias ferramentas com o prop√≥sito de teste, como o¬†**`Jest`**¬†e o¬†**`assert`**.

O¬†`Jest`, que aprendemos no m√≥dulo de Fundamentos, foi originalmente projetado para o React, mas funciona em outros projetos Javascript. Outra caracter√≠stica do¬†`Jest`¬†√© que ele √© focado principalmente em testes de unidade e na simplicidade e n√£o requer nenhuma configura√ß√£o, ou seja, ap√≥s sua instala√ß√£o, ele est√° preparado para ser utilizado. Os testes s√£o paralelos e executados em seus pr√≥prios processos para maximizar o desempenho. Possui suporte integrado para execu√ß√£o autom√°tica de testes a cada altera√ß√£o no c√≥digo. Mas n√£o oferece suporte a testes ass√≠ncronos.

A nova ferramenta para teste que vamos aprender √© o¬†`Mocha`. Ele foi originalmente projetado para o¬†**Node.js**. √â focado em v√°rios tipos de testes, como unidade, integra√ß√£o e ponta a ponta (E2E). Diferente do¬†`Jest`, requer outras bibliotecas para funcionar, como o¬†`chai`¬†e o¬†`sinon`. E, apesar de demandar mais trabalho para configurar e adicionar funcionalidades, esta enorme flexibilidade e uma variedade de recursos adicionais prontos para uso, fornecem ferramentas para um desenvolvedor experiente, principalmente em grandes projetos¬†**Node.js**. Al√©m disso o Mocha suporta testes ass√≠ncronos e √© um framework mais antigo e mais maduro do que o¬†`Jest`, presente em diversos projetos.

Os testes do¬†`Mocha`¬†s√£o executados em s√©rie, permitindo relat√≥rios flex√≠veis e precisos, enquanto mapeia exce√ß√µes n√£o capturadas para os casos de teste corretos. E para complementar os testes do¬†`Mocha`¬†temos o¬†`chai`, que √© uma biblioteca de asser√ß√£o, e o¬†`sinon`, que implementa dubles de teste, como:¬†_spies_,¬†_stubs_¬†e¬†_mocks_.

Para utilizarmos essas ferramentas, precisamos come√ßar¬†**fazendo a instala√ß√£o.**

> Utilizaremos a flag¬†`-D`. Apesar de essenciais durante o desenvolvimento, esses m√≥dulos (ferramentas) n√£o ser√£o utilizados para executar a nossa aplica√ß√£o quando ela for publicada.

Dessa forma, evitamos instalar pacotes desnecess√°rios em nossa vers√£o de produ√ß√£o:

```bash
npm install mocha@8.4.0 chai@4.3.4 --save-dev --save-exact
```

Feita a instala√ß√£o, j√° podemos importar o mocha e o chai em um arquivo¬†`.js`¬†e escrever nossos testes.

Bora fazer isso? üí™

## Estruturando testes com o Mocha

O¬†**[mocha](https://mochajs.org/)¬†√© um¬†_framework_¬†de testes para JS**, isso significa que ele nos ajuda a arquitetar os nossos testes fornecendo a estrutura e interface para escrevermos eles.

Vamos come√ßar pelos comportamentos: precisamos definir o que estamos testando em um caso espec√≠fico. Para isso, o¬†`mocha`¬†nos fornece duas palavras reservadas: o¬†**_describe_**¬†e o¬†**_it_**.

-   O¬†**_describe_**, como o pr√≥prio nome j√° diz, nos permite adicionar uma descri√ß√£o para um teste espec√≠fico ou um grupo de testes.
    
-   O¬†**_it_**¬†nos permite sinalizar exatamente o cen√°rio que estamos testando naquele ponto.
    

Nos testes que escrevemos ‚Äúna m√£o‚Äù, o mocha substitui aqueles logs que utilizamos para descrever cada teste. Bora ver na pr√°tica como podemos fazer isso com a ajuda do¬†`mocha`!

No exemplo que utilizamos para criar uma fun√ß√£o que recebe a m√©dia das notas de uma pessoa, utilizamos o log abaixo para ‚Äúdescrever‚Äù nosso cen√°rios de teste.


```js
console.log('Quando a m√©dia for maior que 7, retorna "aprovado":');
```

Agora, usando o¬†`describe`¬†podemos definir a seguinte representa√ß√£o para descrever o mesmo cen√°rio:

```js
describe('Quando a m√©dia for menor que 7', function () {
  //
});
```

> **Perceba que o¬†`describe`¬†aceita dois par√¢metros:**(I) o primeiro √© uma string, onde podemos passar a descri√ß√£o, (II) o segundo √© uma fun√ß√£o para executar o cen√°rio de teste.
> 
> Outro ponto de aten√ß√£o √©, que n√£o √© necess√°rio importar o¬†`mocha`¬†em nosso arquivo, pois suas palavras reservadas ser√£o interpretadas quando executarmos os testes, mas veremos mais adiante como faz√™-lo.

De olho na dica üëÄ: Veja que usamos a sintaxe¬†`function`¬†ao inv√©s de¬†_arrow functions_. Essa sintaxe √© uma recomenda√ß√£o da pr√≥pria documenta√ß√£o do mocha. O uso da¬†_arrow function_¬†pode restringir o acesso ao contexto de como o mocha trabalha por baixo dos panos. para mais informa√ß√µes acesse esse¬†[link](https://mochajs.org/#arrow-functions)¬†da documenta√ß√£o oficial.

Descrito nosso comportamento, vamos adicionar o que ser√° testado de fato, ou seja, o que √© esperado. Para isso, usamos o¬†`it`:

```js
describe('Quando a m√©dia for menor que 7', function () {
  it('retorna "reprova√ß√£o"', function () {
    //
  });
});
```

Anota a√≠ üñä: A sintaxe do¬†`it`¬†√© bem semelhante a do¬†`describe`: ela aceita uma string, que define o comportamento a ser testado, e uma fun√ß√£o que executa os testes de fato.

At√© agora, n√≥s j√° vimos como descrever os cen√°rios de teste, mas como verificar se o nosso c√≥digo est√° de acordo com esse cen√°rio? ü§î

√â o que veremos a seguir!

---

## Aferindo testes com o Chai

O¬†**`chai`¬†nos ajudar√° com as asser√ß√µes, ou seja, ele nos fornece maneiras de dizermos o que queremos testar**¬†validando se o resultado condiz com o esperado.

At√© aqui, n√£o estamos testando nada de fato, apenas descrevemos o teste.

Anota a√≠ üñä: Para de fato testar nossa fun√ß√£o, precisamos cham√°-la passando o input desejado e ent√£o validar se a resposta √© aquela que esperamos. Essa valida√ß√£o √© o que chamamos de¬†_assertion_,¬†**‚Äúasser√ß√£o‚Äù**¬†ou, em alguns casos,¬†**‚Äúafirma√ß√£o‚Äù**.

Para nos ajudar com essa tarefa, o¬†`chai`¬†nos fornece diversos tipos de valida√ß√µes diferentes.

‚ö†Ô∏è Aviso: Usaremos a interface¬†`expect`¬†do¬†`chai`¬†em nossos exemplos, que significa de fato o que √©¬†**esperado**¬†para determinada vari√°vel:

```js
const { expect } = require('chai');
const resposta = calculaSituacao(4);

expect(resposta).equals('reprova√ß√£o');
```

No c√≥digo acima, estamos chamando nossa fun√ß√£o. Logo em seguida,¬†**afirmamos**¬†que seu retorno armazenado na constante¬†`resposta`, deve ser¬†_igual_¬†(`equals`) a¬†`reprova√ß√£o`.

Muito mais leg√≠vel e simples, n√£o √© mesmo!?

> Observe que o¬†`chai`¬†foi importado no in√≠cio do arquivo e o¬†`expect`¬†foi desconstru√≠do a partir dele. Agora, perceba como o¬†`chai`¬†nos fornece uma fun√ß√£o pronta, a¬†`equals`¬†que vai comparar se o valor ‚Äúesperado‚Äù na¬†_resposta_¬†√©¬†**igual**¬†ao passado para ele, ou seja, igual a ‚Äúreprova√ß√£o‚Äù.

De olho na dica üëÄ: a asser√ß√£o¬†`equals`¬†√© uma das diversas asser√ß√µes dispon√≠veis no chai. A lista completa pode ser encontrada na¬†[documenta√ß√£o oficial do chai](https://www.chaijs.com/api/bdd/).

Para tornar nosso teste ainda mais leg√≠vel e elegante, o chai nos fornece outros¬†_getters_¬†encade√°veis que possuem um papel puramente est√©tico.

Por exemplo, o¬†`to`¬†e o¬†`be`, que nos permitem escrever nossa¬†_assertion_¬†da seguinte maneira:

> tests/calculaSituacao.js

```js
const { expect } = require('chai');

const calculaSituacao = require('../examples/calculaSituacao');

describe('Quando a m√©dia for menor que 7', function () {
  it('retorna "reprova√ß√£o"', function () {
    const resposta = calculaSituacao(4);

    expect(resposta).to.be.equals('reprova√ß√£o');
  });
});
```

> Perceba que o¬†`to`¬†e o¬†`be`¬†n√£o alteraram em nada a valida√ß√£o realizada, por√©m a leitura fica muito mais fluida e natural. √â como se estiv√©ssemos dizendo que nosso teste espera a resposta¬†**ser igual**¬†a ‚Äúreprova√ß√£o‚Äù.

De olho na dica üëÄ: podemos encontrar um pouco mais sobre esse getters na documenta√ß√£o oficial do¬†_chai_, em¬†[language chains](https://www.chaijs.com/api/bdd/#method_language-chains).

Agora que j√° vimos um pouco sobre testes automatizados e ferramentas, precisamos pensar sobre qual o melhor momento para estabelecer os cen√°rios e automatiza-los.

**‚è∞ Hora da reflex√£o**: em qual momento voc√™ deveria come√ßar a pensar nos seus testes? Imagine que seu c√≥digo √© um novo tipo de material desenvolvido para a sustenta√ß√£o de um pr√©dio. Voc√™ s√≥ iria pensar nos testes ap√≥s a finaliza√ß√£o do pr√©dio? ü§î

√â sob esse ponto de vista que iremos conhecer uma nova forma para construir nossas aplica√ß√µes, priorizando a qualidade do nosso c√≥digo e melhorando nossa experi√™ncia de desenvolvimento.

# Testes de Integra√ß√£o

Como vimos, nos testes manuais h√° uma esp√©cie de ‚Äúretrabalho‚Äù com a implementa√ß√£o, pois primeiro escrevemos uma primeira vers√£o do c√≥digo para depois identificar o erro e a√≠ corrigi-lo. Em contrapartida a isso, temos o¬†**`TDD`¬†(Test Driven Development)**, em tradu√ß√£o livre,¬†_Desenvolvimento Orientado a Testes_, cuja ideia principal consiste em come√ßar a escrever os testes, que traduzem e validam os comportamentos esperados para aquele c√≥digo, antes de iniciar a implementa√ß√£o. Contudo, como no¬†_TDD_¬†estamos escrevendo testes para c√≥digos que ainda n√£o existem, √© completamente normal que um detalhe ou outro possam¬†_‚Äúescapulir‚Äù_¬†√† mente e que haja a necessidade de fazer algum ajuste nos testes.

A pr√°tica do TDD pode ser empregada nos diferentes tipos de teste, por enquanto, iremos focar nos¬†**testes de integra√ß√£o**. Empregando esses testes, em conjunto com a metodologia TDD, iremos construir nosso c√≥digo de forma mais f√°cil e com maior garantia de que estamos considerando todos os cen√°rios.

Relembrandoüß†: Os testes de integra√ß√£o, ou¬†_integration tests_, servem para verificar se a comunica√ß√£o entre os componentes de um sistema est√° ocorrendo da forma esperada. Diferentemente dos testes unit√°rios, onde isolamos as unidades, a ideia aqui √© juntar todas elas e ver a m√°gica acontecer.

> Isso n√£o que dizer que os testes de integra√ß√£o s√£o melhores que os testes unit√°rios. Ambos s√£o importantes, por√©m, cada um tem um objetivo diferente.

![Testes Unitarios VS Testes de Integracao](https://content-assets.betrybe.com/prod/Testes%20Unitarios%20VS%20Testes%20de%20Integracao.gif)

Testes Unit√°rios VS Testes de Integra√ß√£o

Da mesma forma que definir uma unidade √© subjetivo, n√£o existe um n√≠vel de granularidade espec√≠fico de integra√ß√£o para ser testada, sendo poss√≠vel adaptar esse conceito de acordo com os objetivos de teste desejados. Em outras palavras, isso ir√° depender do objetivo de teste para definir se uma unidade √© composta por apenas uma fun√ß√£o, um conjunto de fun√ß√µes relacionadas ou at√© mesmo um √∫nico¬†_endpoint_.

‚ö†Ô∏è Aviso: Nossa integra√ß√£o, por enquanto, partir√° do recebimento do objeto da requisi√ß√£o (`request`) em uma API, seguindo por fun√ß√µes incorporadas pelo¬†_endpoint_¬†at√© a devolu√ß√£o do objeto de resposta (`response`) dessa requisi√ß√£o.

> Veja que estamos fazendo a integra√ß√£o de poucas unidades at√© este momento (_endpoint_¬†e fun√ß√µes). Posteriormente, iremos evoluir um pouco mais essa integra√ß√£o para abordar diferentes quantidades e tipos de unidades.

Voc√™ pode estar se perguntando: ‚ÄúMas onde o TDD entra nessa hist√≥ria?‚Äù üëÄ

> Para melhor exemplificar a pr√°tica do TDD com testes de integra√ß√£o, mais adiante, iremos construir uma API empregando esses dois conceitos. Come√ßaremos pela defini√ß√£o dos cen√°rios de teste e √† medida que os testes falharem, desenvolveremos funcionalidades necess√°rias para que o teste seja executado com sucesso. Vamos repetir esse processo at√© que todos os cen√°rios tenham sido desenvolvidos.


# Contratos de APIs

Sempre que consumimos ou fornecemos um servi√ßo, como por exemplo uma API REST, precisamos ter os comportamentos predefinidos. Esses comportamentos s√£o definidos de acordo com¬†**as regras de entrada e sa√≠da de dados da API**.

> Por exemplo: ao chamar um endpoint¬†`GET /users/:userId`, passamos um ID de pessoa usu√°ria e esperamos receber os dados referentes √†quele pessoa com um c√≥digo http¬†`200 - OK`. Caso a pessoa usu√°ria n√£o seja encontrada, esperamos receber um status http¬†`404 - Not Found`, por exemplo.

Perceba que podemos ter diversos padr√µes definidos e comportamentos esperados. Dessa forma, √© importante testar se esses comportamentos est√£o sendo cumpridos por nossas APIs, retornando uma resposta compat√≠vel com o cen√°rio.

Anota a√≠ üñä: Em uma API, o conceito definido por essas regras √© chamado de¬†**contrato**. O contrato define aquilo que foi previamente acordado, ou seja, como a API dever√° se comportar em um determinado cen√°rio.

Para ficar ainda mais n√≠tido, vamos utilizar novamente o endpoint¬†`GET /users/:userId`. Podemos dizer que o contrato dele √©:¬†**quando a pessoa usu√°ria existe, retornar a seguinte resposta**:

-   C√≥digo HTTP:¬†`200 - OK`;
-   Body:

```json
{
  "id": "123",
  "name": "Dwight",
  "fullName": "Dwight Schrute",
  "email": "dwightschrute@dundermifflin.com"
}
```

Esse conceito trabalha muito bem junto com os testes de integra√ß√£o, pois podemos testar se cada contrato est√° sendo cumprido ap√≥s o processamento de todas as fun√ß√µes internas de um¬†_endpoint_.


# Definindo os cen√°rios de teste

Para exemplificar como funciona o teste de integra√ß√£o, iremos construir uma nova API chamada Cacau Trybe, uma API que fornece¬†_endpoints_¬†para gerenciar uma lista de chocolates de diferentes marcas da Fran√ßa üç´.

Seguindo as premissas do TDD, a primeira quest√£o que devemos nos preocupar s√£o os cen√°rios de teste. Esses cen√°rios, al√©m de validar o nosso c√≥digo, ir√£o representar os contratos definidos para essa API.

Bora conhecer esses contratos? üìÑ

A API Cacau Trybe ser√° composta por tr√™s¬†_endpoints_, representados pelos seguintes contratos:

üëâ¬†**GET**¬†_`/chocolates`_

-   Objetivo: Retornar uma lista com todos os chocolates cadastrados.
-   C√≥digo HTTP:¬†`200 - OK`;
-   Body (exemplo):

```json
  [
    { "id": 1, "name": "Mint Intense", "brandId": 1 },
    { "id": 2, "name": "White Coconut", "brandId": 1 },
    { "id": 3, "name": "Mon Ch√©ri", "brandId": 2 },
    { "id": 4, "name": "Mounds", "brandId": 3 }
  ]
```

üëâ¬†**GET**¬†_`/chocolates/:id`_

-   Objetivo: Buscar um chocolate espec√≠fico pelo ID.
-   C√≥digo HTTP:¬†`200 - OK`;
-   Body (exemplo):


```json
  [
    {
      "id": 4,
      "name": "Mounds",
      "brandId": 3
    }
  ]
```

üëâ¬†**GET**¬†_`/chocolates/brand/:brandId`_

-   Objetivo: Buscar uma lista de chocolates pelo ID (brandId) da marca.
-   C√≥digo HTTP:¬†`200 - OK`;
-   Body (exemplo):

```json
[
  {
      "id": 1,
      "name": "Mint Intense",
      "brandId": 1
  },
  {
      "id": 2,
      "name": "White Coconut",
      "brandId": 1
  }
]
```

Com os contratos definidos, √© hora de escrever nossos testes.



###### Fonte: [Curse](https://app.betrybe.com/learn/course/5e938f69-6e32-43b3-9685-c936530fd326/module/94d0e996-1827-4fbc-bc24-c99fb592925b/section/2ed87e4f-9049-4314-8091-8f71b1925cf6/day/4684c963-8015-41ad-a901-eb37076d9ff5/lesson/32ad61bd-476f-4877-826d-a3b127ba89e6)
